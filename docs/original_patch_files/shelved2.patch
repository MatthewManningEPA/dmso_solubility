IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import itertools\r\nimport os\r\nfrom time import sleep\r\n\r\nimport padel_categorization\r\nimport qsar_readiness\r\nfrom qsar_readiness import QSAR_COLUMNS\r\nimport pandas as pd\r\nimport numpy as np\r\nimport DescriptorRequestor\r\n\r\n\r\n# TODO: Calculate and plot descriptive stats\r\n# TODO: Filter compounds by MW, peptides, etc.\r\n# TODO: Eliminate compounds/features with higher NaN values\r\n# TODO: Feature agglomeration\r\n# TODO: Feature selection\r\n\r\ndef get_api_descriptors(qsar_df, desc_path, desc_set='padel'):\r\n    desc_grabber = DescriptorRequestor.DescriptorGrabber(desc_set=desc_set, timeout=(30, 600))\r\n    desc_list = list()\r\n    inchi_dict = pd.Series(qsar_df.index.values, index=qsar_df['SMILES']).to_dict()\r\n    with open(desc_path, 'a'):\r\n        for desc, smile in desc_grabber.bulk_epa_call(qsar_df['SMILES'].tolist()):\r\n            if not isinstance(desc, dict):\r\n                exit()\r\n            else:\r\n                desc.update(('FOREIGN_KEY', inchi_dict[smile]))\r\n                desc_list.append(desc)\r\n\r\n\r\ndef map_cols(df, original, new):\r\n    qsar_map = dict(zip(df[original], df[new]))\r\n    return qsar_map\r\n\r\n\r\ndef extract_cached_desc(qsar_ready_df, cached_df):\r\n    # Find SMILES column in both dfs, check for union (recheck for different smiles column), return descriptor df\r\n    upper_cache_cols = [x for x in cached_df.columns.tolist() if ('QSAR' in x.upper() or 'SMILE' in x.upper())]\r\n    last_num = 0\r\n    best_match, best_col, qsar_col = None, None, None\r\n    for col, qsar_col in itertools.product(upper_cache_cols, ['SMILES', 'CANONICAL_SMILES']):\r\n        cache_smiles = pd.Index(cached_df[col].squeeze().tolist())\r\n        qsar_smiles = pd.Index(qsar_ready_df[qsar_col].squeeze().tolist())\r\n\r\n        # Find QSAR column, if different from SMILES, convert column to SMILES\r\n\r\n        matches = qsar_smiles.intersection(cache_smiles)\r\n        if len(matches.tolist()) > last_num:\r\n            last_num = len(matches.tolist())\r\n            best_col = (col, qsar_col)\r\n            best_match = matches\r\n    smiles_matches = pd.Index(qsar_ready_df['SMILES'].squeeze().tolist()).intersection(cached_df.index)\r\n    canon_matches = pd.Index(qsar_ready_df['CANONICAL_SMILES'].squeeze().tolist()).intersection(cached_df.index)\r\n    if last_num == 0:\r\n        return pd.DataFrame([]), None\r\n    elif len(smiles_matches) > last_num and len(canon_matches):\r\n        return cached_df.loc[smiles_matches].rename(index=map_cols(qsar_ready_df, 'SMILES', 'INCHI_KEY'),\r\n                                                    inplace=True), 'SMILES'\r\n    elif len(canon_matches) > last_num:\r\n        return cached_df.loc[canon_matches].rename(index=map_cols(qsar_ready_df, 'CANONICAL_SMILES', 'INCHI_KEY'),\r\n                                                   inplace=True), 'CANONICAL_SMILES'\r\n    else:\r\n        return cached_df.loc[cached_df[best_col[0]].isin(best_match.tolist())].rename(\r\n            index=map_cols(qsar_ready_df, best_col[1], 'FOREIGN_KEY'), inplace=True), best_col[1]\r\n\r\n\r\ndef get_api_desc(desc_path, qsar_df, d_set):\r\n    grabber, desc_names = None, None\r\n    #TODO: Sketch descriptor name getter.\r\n    desc_names = padel_categorization.padel_names\r\n    last_ind = 0\r\n    print(desc_path)\r\n    inchi_dict = pd.Series(qsar_df.index.values, index=qsar_df['SMILES']).to_dict()\r\n    desc_dict = dict()\r\n    ser_list = list()\r\n    grabber = DescriptorRequestor.DescriptorGrabber(d_set)\r\n    for response, smile in grabber.bulk_epa_call(qsar_df['SMILES'].tolist()[last_ind:]):\r\n        if type(response) is dict:\r\n            desc_dict[inchi_dict[smile]] = [response['descriptors']]\r\n            with open(desc_path, 'a') as fo:\r\n                fo.write('{}\\n'.format(response.values()))\r\n            temp_srs = pd.Series(data=response['descriptors'], name=inchi_dict[smile])\r\n            # temp_srs = pd.Series(data=response['descriptors'], index=desc_names, name=inchi_dict[smile])\r\n            ser_list.append(temp_srs)\r\n        else:\r\n            print(smile, response)\r\n            with open(desc_path, 'a') as fo:\r\n                fo.write('{}\\n'.format(response.items()))\r\n    desc_df = pd.concat(ser_list, axis=1).T.rename(QSAR_COLUMNS, inplace=True)\r\n    return desc_df\r\n\r\n\r\ndef main(data_path=None, qsar_df=None, desc_cache=None, qsar_ready_name=None, cache_path=None, desc_set=None, intermetals=False, salt_filter=False):\r\n    \"\"\"\r\n    :param data_path:\r\n    :param cache_path:\r\n    :param qsar_ready_name:\r\n    :param desc_cache: pd.DataFrame,\r\n    :param qsar_df: pd.DataFrame, Contains QSAR Standardizer output\r\n    \"\"\"\r\n    if type(desc_cache) is not pd.DataFrame and cache_path:\r\n        # print(desc_cache)\r\n        desc_cache = pd.read_pickle('{}{}.pkl'.format(cache_path, qsar_ready_name))\r\n    # if not type(qsar_df) is not pd.DataFrame and qsar_ready_name:\r\n    #    print(qsar_df)\r\n    #    qsar_df = pd.read_pickle('{}{}.pkl'.format(data_path, qsar_ready_name))\r\n    qsar_df.rename(mapper=QSAR_COLUMNS, inplace=True)\r\n    salts, intermetallics = qsar_readiness.salts_and_intermetallics(qsar_df['SMILES'].tolist(), intermetallics=intermetals)\r\n    if salt_filter and len(salts) > 0:\r\n        salt_df = qsar_df[qsar_df['SMILES'].isin(salts)]\r\n        salt_df.to_pickle('{}SALTS_{}.pkl'.format(data_path, qsar_ready_name))\r\n        qsar_df.drop(index=salt_df.index, inplace=True)\r\n    if intermetallics and len(intermetallics) > 0:\r\n        intermetallics_df = qsar_df[qsar_df['SMILES'].isin(intermetallics)]\r\n        intermetallics_df.to_pickle('{}INTERMETALLICS_{}.pkl'.format(data_path, qsar_ready_name))\r\n        qsar_df.drop(index=intermetallics_df.index, inplace=True)\r\n    if type(desc_cache) is pd.DataFrame and not desc_cache.empty:\r\n        cached_values, qsar_col_name = extract_cached_desc(qsar_df, desc_cache)\r\n        missing_desc = qsar_df.loc[qsar_df.index.difference(cached_values.index)]\r\n    else:\r\n        missing_desc = qsar_df\r\n    print(missing_desc.shape)\r\n    api_desc = get_api_desc('{}{}/{}_{}.csv'.format(data_path, desc_set, desc_set.upper(), qsar_ready_name),\r\n                            missing_desc, desc_set)\r\n    if desc_cache and type(desc_cache) is pd.DataFrame and desc_cache.empty:\r\n        all_desc = pd.concat([cached_values, api_desc], axis=1, verify_integrity=True, sort=True)\r\n    else:\r\n        all_desc = api_desc\r\n    return all_desc\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dmso_model_dev/descriptor_processing.py b/dmso_model_dev/descriptor_processing.py
--- a/dmso_model_dev/descriptor_processing.py	
+++ b/dmso_model_dev/descriptor_processing.py	
@@ -1,13 +1,12 @@
 import itertools
 import os
-from time import sleep
 
-import padel_categorization
-import qsar_readiness
-from qsar_readiness import QSAR_COLUMNS
 import pandas as pd
-import numpy as np
+import qsar_readiness
+
 import DescriptorRequestor
+from dmso_model_dev.data_handling import padel_categorization
+from constants import QSAR_COLUMNS
 
 
 # TODO: Calculate and plot descriptive stats
